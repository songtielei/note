createdAt: "2021-01-30T07:44:26.158Z"
updatedAt: "2021-01-30T08:19:06.858Z"
type: "MARKDOWN_NOTE"
folder: "2d90bb286c7337ef5d47"
title: "equals与==区别"
tags: []
content: '''
  - equals与==区别
  
      == 的作用：
      
      基本类型：比较的就是值是否相同
      引用类型：比较的就是地址值是否相同
      
      equals 的作用:
      
      引用类型：默认情况下，比较的是地址值 (Object中的equals方法)。 String Integer Date 等类覆写了该方法 比较的是对象的值
     
      ==比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象
      
      所有整型包装类对象之间值的比较，全部使用 equals 方法比较 对于 Integer var = ? 在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象
      
      BigDecimal 要用compareTo 方法比较 因为BigDecimal不仅比较值还比较精度 new BigDecimal(1.0) 与 new BigDecimal(1.00) 用equals比较不相等
  
  - 常用集合类
  
      List 列表，有序、可重复
      Map 映射/字典，无序，键值对，键唯一
      Set 集合，不可重复
  
  - Hashmap底层原理
      
      hashmap是数组 链表 红黑树组成的 不同的对象算出来的数组下标是相同的这样就会产生hash冲突 冲突后会用链表存储 当链表达到一定长度后，链表就会变成红黑树
      
      扩容
      
      数组长度变成2倍 0.75
      
      触发条件
      
      数组存储比例达到75% – 0.75
      
      链表变成红黑树触发条件
      
      在链表长度大于8的时候，将后面的数据存在红黑树中
      
  - 并发场景业务处理
  - redis应用场景
  
      1、热点数据的缓存
      由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作。
  
      2、限时业务的运用
      redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。
  
      3、计数器相关问题
      redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。
  
      4、排行榜相关问题
      关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。
  
      5、分布式锁
      这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，服务器是集群部署时，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。
       当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。
  
  
  - redis 支持的数据类型有哪些
  
      Redis支持五种数据类型：string（字符串）hash（哈希）list（列表）set（集合）及zset(sorted set：有序集合)。
      
      String（字符串）
      
      string 是 redis 最基本的类型，一个 key 对应一个 value。
  
      redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。
  
      string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。
  
      Hash（哈希）
      
      Redis hash 是一个键值(key=>value)对集合。
  
      Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。
      
      List（列表）
      
      Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
      
      Set（集合）
      
      Redis 的 Set 是 string 类型的无序集合。
  
      集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。
      
      zset(sorted set：有序集合)
      
      Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
  
      zset的成员是唯一的,但分数(score)却可以重复。
      
  - token在redis中设置的过期是多长？为什么这么设计
  
      默认12小时 防止token泄漏后的攻击
      
  - 在项目中有几种乐观锁的实现方式
  
      版本号机制
      
      一般是在数据表中加上版本号字段 version，表示数据被修改的次数。当数据被修改时，这个字段值会加1。
      
      CAS 算法
      即 compare and swap（比较与交换），是一种无锁算法。无锁编程，即不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数：
  
      需要读写的内存值 V
      进行比较的值 A
      拟写入的新值 B
      当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个 native 原子操作）。一般情况下，这是一个自旋操作，即不断的重试。
  
  
  - Mysql的性能优化
  - Mysql事务的四大特性
  
      事务：把一组密不可分的操作系列集合在一起，这些操作要么全部执行，要么全部不执行。
  
      1.原子性：事务是内定义的操作是一个整体，是不可分割的。
  
      2.一致性：同一个事务，多次读取数据库中的同一个数据，读取的内容应该是一致的，不变的。
  
      3.隔离性：不同事务之间相互独立，互不干扰。
  
      4.持久性：事务提交后，事务内的操作对数据库的修改被永久保存在数据库文件中。
  
  - 说一下mysql的脏页
  - 说一下数据库的事务隔离
      
      事务隔离级别要实际解决的问题:
      
      脏读
  
      脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
  
      不可重复读
  
      对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。
  
      幻读
  
      幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。
      
      SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是:
      
      读未提交（READ UNCOMMITTED）
      
      读提交 （READ COMMITTED）
      
      可重复读 （REPEATABLE READ）
      
      串行化 （SERIALIZABLE）
      
  ![47712c68.png](:storage/0a782a8e-43af-4d43-90d8-6895eadc906f/47712c68.png)
  
  ![5f2ea4fc.png](:storage/0a782a8e-43af-4d43-90d8-6895eadc906f/5f2ea4fc.png)
  
  - mybatis 分页插件的实现原理是什么
  
      MyBatis有四大核心对象：
  
      1. ParameterHandler：处理SQL的参数对象
      2. ResultSetHandler：处理SQL的返回结果集
      3. StatementHandler：数据库的处理对象，用于执行SQL语句
      4. Executor：MyBatis的执行器，用于执行增删改查操作
  
      MyBatis拦截器针对的对象就是上面4个对象。
      一旦配置上插件，ParameterHandler，ResultSetHandler，StatementHandler，Executor这四大核心对象，将会变成代理对象，而不再是原对象
  
  - 简单说说线程池的原理和实现
  
      线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用
      
      ThreadPoolExecutor UML类图
      ![3206c88f.png](:storage/0a782a8e-43af-4d43-90d8-6895eadc906f/3206c88f.png)
      
      ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。
      
      ThreadPoolExecutor运行流程
      ![b358d76b.png](:storage/0a782a8e-43af-4d43-90d8-6895eadc906f/b358d76b.png)
      
  - 线程池用法，应用场景
  
      ```
      ExecutorService executorService = new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
      executorService.submit(new Callable<Object>() {
          @Override
          public Object call() throws Exception {
              return null;
          }
      });
      executorService.shutdown();
      ```
      
  - 什么是死锁？怎么防止死锁
  
      死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程
      
      死锁产生的原因
      
      系统资源的竞争: 当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。
  
      进程运行推进顺序不当引起死锁: 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。
      
      产生死锁的四个必要条件：
  
  　　 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
  
  　　 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
  
  　　 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
  
  　　 循环等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
  
  　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
    
  - 存储过程的结构和优点
  - 谈谈你对JVM的理解
  
      JVM是Java Virtual Machine的缩写。它是一种基于计算设备的规范，是一台虚拟机，即虚构的计算机。
  
      JVM屏蔽了具体操作系统平台的信息（显然，就像是我们在电脑上开了个虚拟机一样），当然，JVM执行字节码时实际上还是要解释成具体操作平台的机器指令的。
  
      通过JVM，Java实现了平台无关性，Java语言在不同平台运行时不需要重新编译，只需要在该平台上部署JVM就可以了。因而能实现一次编译多处运行。(就像是你的虚拟机也可以在任何安了VMWare的系统上运行)
  
  - 为什么要有GC机制
  - mq应用场景
  
      应用解耦
      流量削锋
      
  - Dubbo使用
  - spring cloud 的核心组件有哪些
  
      1. 服务发现——Netflix Eureka
      2. 客服端负载均衡——Netflix Ribbon
      3. 断路器——Netflix Hystrix
      4. 服务网关——Netflix Zuul
      5. 分布式配置——Spring Cloud Config
  
  - 幂等性场景
  
      微服务架构下，不同微服务间会有大量的基于http,rpc或者mq消息的网络通信，如果超时了，微服务框架会进行重试。
  
     用户交互的时候多次点击,无意地触发多笔交易。
  
     MQ消息中间件，消息重复消费
  
     第三方平台的接口（如：支付成功回调接口），因为异常也会导致多次异步回调
  
     其他中间件/应用服务根据自身的特性，也有可能进行重试。
'''
linesHighlighted: []
isStarred: false
isTrashed: false
